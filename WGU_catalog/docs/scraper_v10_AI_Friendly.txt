Here’s a token-minimized, AI-friendly version of your scraping logic — suitable for modular AI pipelines or LLM-assisted agents. Focus is on clean I/O, module registration, pattern names, minimal narrative.

⸻

✅ anchors_and_patterns.py — register all regex patterns

# anchors_and_patterns.py

import re

ANCHORS = {
    "CCN_HEADER": re.compile(r"CCN.*Course Number", re.I),
    "COURSE_CODE": re.compile(r"^[A-Z]{2,4}\s+\d{4}"),
    "COURSES_SECTION": re.compile(r"^Courses", re.I),
    "PROGRAM_OUTCOMES": re.compile(r"^Program Outcomes$", re.I),
    "SCHOOL_OF": re.compile(r"^School of ", re.I),
    "FOOTER_COPYRIGHT": re.compile(r"©", re.I),
    "FOOTER_TOTAL_CUS": re.compile(r"Total CUs", re.I),
}

FILTERS = {
    "EXCLUDE_PROGRAM_TITLE": re.compile(r"^(Steps|[0-9]|[•\-])"),
}

COURSE_PATTERNS = {
    "CCN_FULL": re.compile(r'^([A-Z]{2,5})\s+(\d{1,4})\s+([A-Z0-9]{2,5})\s+(.+?)\s+(\d+)\s+(\d+)$'),
    "CODE_ONLY": re.compile(r'^([A-Z0-9]{1,6})\s+(.+?)\s+(\d+)\s+(\d+)$'),
    "FALLBACK": re.compile(r'^(.+?)\s+(\d+)\s+(\d+)$'),
}


⸻

✅ snapshot.py — pick version ≤ catalog_date

# snapshot.py

import json

def load_snapshot(path):
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def pick_snapshot(date_str, versions_dict):
    versions = sorted(versions_dict)
    for version in reversed(versions):
        if version <= date_str:
            return versions_dict[version]
    raise ValueError(f"No snapshot found for {date_str}")


⸻

✅ matcher.py — match course row

# matcher.py

def match_course_row(row, patterns):
    for name, pattern in patterns.items():
        m = pattern.match(row)
        if m:
            return {"matched": name, "groups": m.groups()}
    return None


⸻

✅ locator.py — locate start of degree section

# locator.py

def get_program_section_start(lines, anchors, colleges):
    for i, line in enumerate(lines):
        if anchors["CCN_HEADER"].search(line):
            for j in range(i, -1, -1):
                if lines[j].strip() in colleges:
                    return j
            break
    raise ValueError("No College header above CCN table")


⸻

✅ fence_builder.py — map start/stop of all degrees

# fence_builder.py

import re

def build_degree_fences(lines, degrees_by_college, anchors):
    fences = {}
    for college, degrees in degrees_by_college.items():
        fences[college] = {}
        for degree in degrees:
            try:
                start = lines.index(degree)
            except ValueError:
                continue
            stop = len(lines)
            for i in range(start + 1, len(lines)):
                line = lines[i]
                if line in degrees and line != degree:
                    stop = i
                    break
                if any(anchor.search(line) for anchor in anchors.values()):
                    stop = i
                    break
            fences[college][degree] = [start, stop]
    return fences


⸻

✅ course_extractor.py — extract all course rows from degree block

# course_extractor.py

def extract_courses(block_lines, anchors, pattern):
    rows = []
    inside = False
    for line in block_lines:
        if anchors["CCN_HEADER"].search(line):
            inside = True
            continue
        if inside:
            if anchors["FOOTER_TOTAL_CUS"].search(line) or anchors["FOOTER_COPYRIGHT"].search(line):
                break
            if pattern.match(line):
                rows.append(line)
    return rows


⸻

✅ flatten_courses.py — output to CSV

# flatten_courses.py

import csv

def flatten_course_index(course_index, output_csv_path):
    rows = []
    for code, data in course_index.items():
        name = data.get("canonical_title", "").strip()
        colleges = sorted({i.get("college", "") for i in data.get("instances", [])})
        rows.append({
            "CourseCode": code,
            "CourseName": name,
            "Colleges": "; ".join(colleges),
        })

    with open(output_csv_path, "w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=["CourseCode", "CourseName", "Colleges"])
        writer.writeheader()
        writer.writerows(rows)


⸻

Summary

Module	Purpose
anchors_and_patterns.py	Defines regex patterns and anchors
snapshot.py	Picks closest snapshot by date
matcher.py	Classifies course row format
locator.py	Finds start of College section
fence_builder.py	Finds start/stop lines for Degrees
course_extractor.py	Gets course lines inside Degree block
flatten_courses.py	Outputs CSV of course info
